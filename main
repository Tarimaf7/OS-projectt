
import java.util.Scanner;
import java.io.PrintWriter;
import java.io.IOException;
public class Scheduler {
	 //static PCB[] CPU;
    public static void main(String []args){
        
        Scanner read = new Scanner (System.in);
        int choice;
        PCB[] Q1;
        PCB[] Q2;
        PCB[] cpu;//the scheduling Q
        do{
        System.out.print("Enter your choice!: ");
        choice = read.nextInt();
        int n1=0;//the actual length of Q1
        int n2=0;//the actual length of Q2
        int numP;
        switch(choice){
            case 1:
            	//scheduling the processes
                System.out.println("Enter the number of processes: ");
                numP=read.nextInt();
                Q1= new PCB[numP];
                Q2=new PCB[numP];
                for(int i=0; i<numP ; i++){
                	
                    System.out.println("Enter process information: ");
                    System.out.println("Process ID: ");
                    int ID=read.nextInt();
                    System.out.println("Priority: ");
                    int pri=read.nextInt();
                    System.out.println("Arrival time: ");
                    int arrTime=read.nextInt();
                    System.out.println("CPU burst time: ");
                    
                    int CPUburst=read.nextInt();
                   
                    
                    PCB obj = new PCB(ID, pri,arrTime, CPUburst );
                    
                    if(pri==1){
                        Q1[n1]=obj;
                        n1++;} 
                    else{
                        Q2[n2]=obj;
                        n2++;}
                    //to get the original cpu of Q1 burst time
                    int burstTime[]=new int[numP] ;
                    for (int n=0; n<n1 ; n++){
                        if (Q1[n]!=null){
                            burstTime[n]=Q1[n].getCPUBurstTime();
                            
                        }
                        
                    }
                    
                }
               
                PCBLinkedList <PCB> helpingQ=new PCBLinkedList<>();
                 cpu=new PCB[numP];
                for (int m=0;m<=n1 ; m++){
                    helpingQ.add(Q1[m]);
                }
                for(int n=0;n<numP;n++){
                    helpingQ.findfirst();
                    if (helpingQ.retrieve().getCPUBurstTime()<=0){
                        if(helpingQ.last()){
                            helpingQ.findfirst();
                        }
                        else{
                            helpingQ.findnext();
                        }
                        
                    }
                    else{
                        cpu[n]=helpingQ.retrieve();
                        helpingQ.retrieve().setCPUBurstTime(helpingQ.retrieve().getCPUBurstTime()-3);
                        
                    }
                }
                
                Sort(Q2);
                int count=0;
                for (int i=0;i<=n2 ;i++){
                if(cpu[i]!=null){
               cpu[i]= Q2[count];
               count++;
               }
               }
                break;
                
            
            case 2:
            
            System.out.println("Enter Termination Time: ");
            int terminationTime = read.nextInt();           
            System.out.println("Enter Arrival Time: ");
            int arrivalTime = read.nextInt();                   
            System.out.println("Enter Start Time: ");
            int startTime = read.nextInt();           
            System.out.println("Enter CPU Burst Time: ");
            int cpuBurstTime = read.nextInt();
             
             PCB o = new PCB(terminationTime,arrivalTime,startTime,cpuBurstTime );
             o.setTerminationTime(terminationTime);  
             o.setArrivalTime(arrivalTime);  
             o.setStartTime(startTime);
             o.setCPUBurstTime(cpuBurstTime);                
         //calculate Termination Time  
         int y =o.getTerminationTime()-o.getArrivalTime();
         o.setTurnAroundTime(y);
         System.out.println(o.getTurnAroundTime());  
         //calculate Waiting Time 
         int z =o.getStartTime()-o.getArrivalTime();
         o.setWaitingTime(z);
         System.out.println(o.getWaitingTime());    
        //calculate Response Time
        int x =o.getTurnAroundTime()-o.getCPUBurstTime();
         o.setResponseTime(x);
         System.out.println(o.getResponseTime());  
             break;    
            
            case 3:
             System.out.println("thank you, bye!");
                 break;
            
                      
                    }
            //all
                            

        }while(choice!=3);
                
        
    }

    public static void Sort(PCB[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (array[j].getCPUBurstTime() > array[j + 1].getCPUBurstTime()) {
                    // Swap array[j] and array[j+1]
                    PCB temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
        return;
    }

  

}

	     
	


