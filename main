
import java.util.Scanner;
import java.io.PrintWriter;
import java.io.IOException;
public class Scheduler {
	 static PCB[] cpu;
    public static void main(String []args){
        
        Scanner read = new Scanner (System.in);
        int choice;
        PCB[] Q1;
        PCB[] Q2;
       
        do{

	System.out.println("1. Enter process' information ");
        System.out.println("2. Report detailed information about each process and different scheduling criteria ");
        System.out.println("3. EXit the program");	
        System.out.print("Enter your choice!: ");
        choice = read.nextInt();
        int n1=0;//the actual length of Q1
        int n2=0;//the actual length of Q2
        int numP;
        switch(choice){
            case 1:
            	  // scheduling the processes
                    System.out.println("Enter the number of processes: ");
                    numP = read.nextInt();
                    Q1 = new PCB[numP];
                    Q2 = new PCB[numP];

                    for (int i = 0; i < numP; i++) {
                        System.out.println("Enter process information: ");
                        System.out.println("Process ID: ");
                        int ID = read.nextInt();
                        System.out.println("Priority: ");
                        pri = read.nextInt();
                        System.out.println("Arrival time: ");
                        int arrTime = read.nextInt();
                        System.out.println("CPU burst time: ");
                        int CPUburst = read.nextInt();

                        PCB obj = new PCB(ID, pri, arrTime, CPUburst);

                        if (pri == 1) {
                            Q1[n1] = obj;
                            n1++;
                        }if (pri == 2){
                        	
                            Q2[n2] = obj;
                            n2++;
                        }
                    }

                    int burstTime[] = new int[numP];
                    for (int n = 0; n < n1; n++) {
                        
                            burstTime[n] = Q1[n].getCPUBurstTime();
                        
                    }

                    PCBLinkedList<PCB> helpingQ = new PCBLinkedList<>();
                    cpu = new PCB[numP];
                    
                    SortArrival(Q1);

                    for (int m = 0; m < Q1.length; m++) {
                    	
                        helpingQ.add(Q1[m]);
                    }
                    
                 int ListSize=length(helpingQ);
                    helpingQ.findfirst();
                    for (int n = 0; n <= ListSize; n++) {
                       // helpingQ.findfirst();
                    	if (helpingQ.retrieve()!=null) {
                        if (helpingQ.retrieve().getCPUBurstTime() <= 0) {
                            if (helpingQ.last()) {
                                helpingQ.findfirst();
                            } else {
                                helpingQ.findnext();
                            }
                        } else {
                            cpu[n] = helpingQ.retrieve();
                            helpingQ.retrieve().setCPUBurstTime(helpingQ.retrieve().getCPUBurstTime() - 3);
                            if(helpingQ.last()) {
                            	helpingQ.findfirst();
                            }
                            else {
                            	helpingQ.findnext();
                            }
                            
                        }
                    }
                    }
                   

                    SortBurst(Q2);
                    int count = 0;
                    while(cpu[count]!=null) {
                    	count++;
                    }
                   
                    for (int i = 0; i < Q2.length; i++) {
                        
                            cpu[count] = Q2[i];
                            
                        
                    }
                   
                    break;
            
            case 2:
          

	
            
            System.out.println("Enter Termination Time: ");
            int terminationTime = read.nextInt();           
            System.out.println("Enter Arrival Time: ");
            int arrivalTime = read.nextInt();                   
            System.out.println("Enter Start Time: ");
            int startTime = read.nextInt();           
            System.out.println("Enter CPU Burst Time: ");
            int cpuBurstTime = read.nextInt();
           
          
            

             
             PCB o = new PCB(terminationTime,arrivalTime,startTime,cpuBurstTime );
             o.setTerminationTime(terminationTime);  
             o.setArrivalTime(arrivalTime);  
             o.setStartTime(startTime);
             o.setCPUBurstTime(cpuBurstTime);                
         //calculate Termination Time  
         int y =o.getTerminationTime()-o.getArrivalTime();
         o.setTurnAroundTime(y);
         System.out.println(o.getTurnAroundTime());  
         //calculate Waiting Time 
         int z =o.getStartTime()-o.getArrivalTime();
         o.setWaitingTime(z);
         System.out.println(o.getWaitingTime());    
        //calculate Response Time
        int x =o.getTurnAroundTime()-o.getCPUBurstTime();
         o.setResponseTime(x);
         System.out.println(o.getResponseTime());  


 try {
         FileWriter fileWriter = new FileWriter(";/Users/joudalfaleh/Desktop/Report.txt");
         PrintWriter printWriter = new PrintWriter(fileWriter);
         printWriter.println("");
         
         printWriter.println();
         printWriter.println("Processes detailed information");
         printWriter.println("---------------------------------");
         
         for (int i = 0; i < cpu.length; i++) {
        	    PCB p = cpu[i];
        	    printWriter.println("Process ID: " + p.getProcessID());
        	    printWriter.println("Priority: " + p.getPriority());
        	    printWriter.println("Arrival Time: " + p.getArrivalTime());
        	    printWriter.println("Start Time: " + p.getStartTime());
        	    printWriter.println("CPU Burst Time: " + p.getCPUBurstTime());
        	    printWriter.println("Termination Time: " + p.getTerminationTime());
        	    printWriter.println("Turnaround Time: " + p.getTurnAroundTime());
        	    printWriter.println("Waiting Time: " + p.getWaitingTime());
        	    printWriter.println("Response Time: " + p.getResponseTime());
        	    printWriter.println("---------------------------------");
        	}
		 printWriter.close();

         
         }catch (IOException e) 
         {
         System.out.println("SOMETHING WENT WRONGE!");
         }
             break;    
            
            case 3:
             System.out.println("thank you, bye!");
                 break;
            
                      
                    }
            //all
                            

        }while(choice!=3);
                
        
    }

   public static void SortBurst(PCB[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                
                    // Swap array[j] and array[j+1]
                   
            	 if (array[j] != null && array[j + 1] != null && array[j].getCPUBurstTime()> array[j + 1].getCPUBurstTime()) {
                        // Swap array[j] and array[j+1]
                        PCB temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                    }
                }
            }
        }
    
    public static void SortArrival(PCB[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                
                    // Swap array[j] and array[j+1]
                   
            	 if (array[j] != null && array[j + 1] != null && array[j].getArrivalTime()> array[j + 1].getArrivalTime()) {
                        // Swap array[j] and array[j+1]
                        PCB temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                    }
                }
            }
        }
    
    public static int length(PCBLinkedList<PCB> list) {
        if (list.isEmpty()) {
            return 0;
        }
        
        list.findfirst();
        int size = 0;
        while (!list.last()) {
            size++;
            list.findnext(); // Move the cursor to the next element
        }
        size++;
        
        return size;
    }
  

}

	     
	


